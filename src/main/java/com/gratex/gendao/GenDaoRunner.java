package com.gratex.gendao;

import static com.gratex.gendao.db.TypeMapRowMapper.removeDatabaseColumnPrefix;
import static java.util.Arrays.asList;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.ZonedDateTime;
import java.util.AbstractMap.SimpleEntry;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;

import com.gratex.gendao.db.Database;
import com.gratex.gendao.db.TypeMap;

public class GenDaoRunner{

	private static Properties staticConfig = null;
	private static Database db = new Database();

	public static void main(String[] args) {
		printLogo();
		try {
			generateClassFromDatabase();
		} finally {
			releaseResources();
		}
	}

	private static void generateClassFromDatabase() {
		for (TypeMap tables : getUserTables()) {
			String tableSchema = tables.getString("table_schema");
			String tableName = tables.getString("table_name");

			String generated;
			if (tableSchema.endsWith("enum") || tableName.startsWith("e_")) {
				generated = generateEnumClass(tableSchema, tableName);
			} else {
				generated = generateDaoClass(tableSchema, tableName);
			}

			System.out.println("generated from: " + tableSchema + "." + tableName + " => " + generated);
		}
	}

	private static String generateEnumClass(String tableSchema, String tableName) {
		Set<String> fields = new LinkedHashSet<>();
		String className = toCammelCase(removeDatabaseColumnPrefix(tableName), true);
		for (TypeMap enumValue : getEnumValues(tableSchema, tableName)) {
			String key = "name";
			if (enumValue.containsKey("code")) {
				key = "code";
			}
			String tablePK = removeDatabaseColumnPrefix(tableName) + "_id";
			String fieldName = enumValue.getString(key);
			Object fieldValue = enumValue.get(tablePK);
			Class<?> fieldType = fieldValue.getClass();
			fields.add(newConstant(fieldType, fieldName, fieldValue, "public", "static", "final"));
		}
//		log(fields);
		generateAndSave(Collections.emptySet(), className, fields, Collections.emptySet(), true);
		return className;
	}

	private static void generateAndSave(Set<String> imports, String className, Set<String> fields, Set<String> methods, boolean isEnum) {
//		File relative = new File("/../src/main/java/" + staticConfig.getProperty("dao.target_package").replace('.', '/'));
		File relative = new File(System.getProperty("user.dir") + "/../src/main/java/" + "com.mkrajcovic.mybooks.dao.enums".replace('.', '/'));
//		System.out.println(relative);
		if (!relative.exists()) {
			relative.mkdirs();
		}
		try {
			Files.write(Paths.get(relative.toPath().toString(), className + ".java"), 
					buildClass(imports, className, fields, methods, isEnum).getBytes());
		} catch (IOException ioex) {
			ioex.printStackTrace();
		}
	}

	private static String buildClass(Set<String> imports, String className, Set<String> fields, Set<String> methods, boolean isEnum) {
		StringBuilder generatedClass = new StringBuilder(resolvePackage());
		if (!imports.isEmpty()) {
			generatedClass.append(imports.stream().collect(Collectors.joining("\n")) + "\n");
		}
		generatedClass.append(getAutoGeneratedComment())
			.append(isEnum ? createEnumClassDeclaration(className) : createDaoClassDeclaration(className))
			.append(fields.stream().collect(Collectors.joining("\n")) + "\n");

		if (!methods.isEmpty()) {
			generatedClass.append("\n").append(methods.stream().collect(Collectors.joining("\n")) + "\n");
		}
		return generatedClass.append("\n}\n").toString();
	}

	private static List<TypeMap> getEnumValues(String tableSchema, String tableName) {
		return db.select()
			.from(tableSchema, tableName)
			.asList();
	}

	private static String generateDaoClass(String tableSchema, String tableName) {
		Set<String> imports = createCommonImports();
		Set<String> fields = new LinkedHashSet<>();
		Set<String> methods = new LinkedHashSet<>();

		String className = toCammelCase(removeDatabaseColumnPrefix(tableName), true);
		TypeMap columnFieldMap = new TypeMap();
		String pk = "t_book_author".equals(tableName) ? "n_book_id" : null;

		for (TypeMap column : getTableColumns(tableSchema, tableName)) {
			Class<?> fieldType = toJavaType(column.getString("data_type"));
			String columnName = column.getString("column_name");
			String fieldName = toCammelCase(removeDatabaseColumnPrefix(columnName));
			String methodName = Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);

			columnFieldMap.put(removeDatabaseColumnPrefix(columnName), new SimpleEntry<>(fieldName, fieldType));
			imports.add(newImport(fieldType));
			fields.add(newField(fieldType, fieldName));
			methods.add(newAccessor(fieldType, fieldName, methodName));
			methods.add(newMutator(fieldType, fieldName, methodName));

			if (pk == null && column.getBooleanDefault("is_primary_key", false)) {
				pk = columnName;
			}
		}

		methods.add(initTableMetadata(tableSchema + "." + tableName, pk));
		methods.add(setByData(className, columnFieldMap));
		methods.add(toTypeMap(columnFieldMap));

//		log(imports);
//		log(fields);
//		log(methods);

		generateAndSave(imports, className, fields, methods, false);
		return className;
	}

	private static String initTableMetadata(String sourceTable, String identifier) {
		return "\t@Override\n"
			+ "\tprotected void initTableMetadata() {\n"
			+ "\t\tsourceTable = \"" + sourceTable + "\";\n"
			+ "\t\tidentifier = \"" + identifier  + "\";\n"
			+ "\t}\n";
	}

	@SuppressWarnings("unchecked")
	private static String setByData(String className, TypeMap columnFieldMap) {
		StringBuilder setByData = new StringBuilder("\t@Override\n\tpublic ")
			.append(className)
			.append(" setByData(TypeMap data) {\n")
			.append("\t\tif (data == null || data.isEmpty()) {\n")
			.append("\t\t\treturn this;\n\t\t}\n")
			.append("\t\tTypeMap map = new TypeMap();\n")
			.append("\t\tmap.putAll(data);\n\n");

		SimpleEntry<String, Class<?>> fieldEntry;
		for (Map.Entry<String, Object> entry : columnFieldMap.entrySet()) {
			fieldEntry = (SimpleEntry<String, Class<?>>) entry.getValue();
			setByData.append("\t\t")
					 .append(fieldEntry.getKey())
					 .append(" = map.get")
					 .append(fieldEntry.getValue().getSimpleName())
					 .append("(\"")
					 .append(entry.getKey())
					 .append("\");\n");
		}
		return setByData.append("\n\t\treturn this;\n\t}\n").toString();
	}

	@SuppressWarnings("unchecked")
	private static String toTypeMap(TypeMap columnFieldMap) {
		StringBuilder toTypeMap = new StringBuilder("\t@Override\n\tpublic TypeMap toTypeMap() {\n\t\treturn new TypeMap(\n");
		for (Map.Entry<String, Object> entry : columnFieldMap.entrySet()) {
			toTypeMap.append("\t\t\t\"")
					 .append(entry.getKey())
					 .append("\", ")
					 .append(((SimpleEntry<String, Class<?>>) entry.getValue()).getKey())
					 .append(",\n");
		}
		int length = toTypeMap.length();
		toTypeMap.delete(length - 2, length);
		return toTypeMap.append(");\n\t}").toString();
	}

	private static List<TypeMap> getUserTables() {
		return db.select("table_schema AS s_table_schema", "table_name AS s_table_name")
			.from("information_schema.tables")
			.whereIn("table_schema", asList("library", "library_enum"))
			.where("table_type", "BASE TABLE")
			.asList();
	}

	private static List<TypeMap> getTableColumns(String tableSchema, String tableName) {
//		return db.select("column_name AS s_column_name", "data_type AS s_data_type")
//			.from("information_schema.columns")
//			.where("table_schema", tableSchema)
//			.where("table_name", tableName)
//			.asList();

	    return db.select(
	    	"A.column_name AS s_column_name", 
	    	"A.data_type AS s_data_type", 
	    	"CASE "
	    	+ "WHEN (B.constraint_name IS NULL) THEN false "
	    	+ "ELSE true "+ 
	    	"END AS b_is_primary_key")
	    	.from("information_schema.columns A")
	    	.leftJoin("(select * from information_schema.constraint_column_usage where constraint_schema = 'library' and constraint_name like '%pkey') B")
	    	.on("A.table_schema", "B.table_schema AND A.table_name = B.table_name AND A.column_name = B.column_name")
	    	.where("A.table_schema", tableSchema)
	    	.where("A.table_name", tableName)
	    	.asList();
	}

	private static String resolvePackage() {
		// TODO: do this from static config
		return "package " + "com.mkrajcovic.mybooks.dao.enums;\n\n";
	}

	private static Class<?> toJavaType(String dbFieldType) {
		switch(dbFieldType) {
		case "integer":
		case "number":
			return Integer.class;
		case "character varying":
		case "text":
		case "varchar":
		case "varchar2":
			return String.class;
		case "boolean":
			return Boolean.class;
		case "timestamp without time zone":
			return LocalDateTime.class;
		case "timestamp with time zone":
			return ZonedDateTime.class;
		default:
			throw new RuntimeException("Cannot find proper java type reference for database type of " + dbFieldType);
		}
	}

	private static String createDaoClassDeclaration(String className) {
		return "public class " + className + " extends DirectlyUpdatableDatabaseObject<" + className + "> {\n\n";
	}

	private static String createEnumClassDeclaration(String className) {
		return "public class " + className + " {\n\n";
	}

	// find these paths by myself ? or make it passed from config?
	private static Set<String> createCommonImports() {
		Set<String> commonImports = new LinkedHashSet<>();
		commonImports.add("import com.mkrajcovic.mybooks.db.DirectlyUpdatableDatabaseObject;");
		commonImports.add("import com.mkrajcovic.mybooks.db.TypeMap;");
		return commonImports;
	}

	private static String newImport(Class<?> type) {
		if (!"java.lang".equals(type.getPackage().getName())) {
			return "import " + type.getTypeName() + ";\n";	
		}
		return "";
	}

	private static String newImport(String literalValue) {
		return "import " + literalValue + ";";
	}

	private static String getAutoGeneratedComment() {
		String username = System.getenv("USER");
		return new StringBuilder()
			.append("/**\n")
			.append(" * This class was generated from database by the gen-dao tool\n")
			.append(" *\n")
			.append(" * @author ")
			.append(username != null ? username : "mkrajcovic")
			.append("\n *\n")
			.append(" */\n").toString();
	}

	private static String newField(Class<?> fieldType, String fieldName) {
		return "\tprotected " + fieldType.getSimpleName() + " " + toCammelCase(fieldName) + ";";
	}

	private static String newConstant(Class<?> fieldType, String fieldName, Object value, String... modifiers) {
		fieldName = fieldName.toUpperCase()
			.replace(' ', '_')
			.replace('-', '_')
			.replace("(", "")
			.replace(")", "");

		return "\t" + String.join(" ", modifiers) + " " + fieldType.getSimpleName() 
			+ " " + fieldName + " = " + formatValue(value) + ";";
	}

	private static Object formatValue(Object value) {
		if (value instanceof CharSequence) {
			return "\"" + value + "\"";
		}
		return value;
	}

	private static String newAccessor(Class<?> fieldType, String fieldName, String methodName) {
		return "\tpublic " + fieldType.getSimpleName() + " get" + methodName
				+ "() {\n\t\treturn this." + fieldName + ";\n\t}\n";
	}

	private static String newMutator(Class<?> fieldType, String fieldName, String methodName) {
		return "\tpublic void set" + methodName + "(" + fieldType.getSimpleName() + " "
				+ fieldName + ") {\n\t\tthis." + fieldName + " = " + fieldName + ";\n\t}\n";
	}

	// use for field names
	private static String toCammelCase(String snakeCase) {
		return toCammelCase(snakeCase, false);
	}

	// use for class and method names
	private static String toCammelCase(String snakeCase, boolean fistCharToUpperCase) {
		String[] nameParts = snakeCase.split("_");
		StringBuilder cammelized = new StringBuilder();
		for (int i = 0; i < nameParts.length; i++) {
			if (i == 0 && !fistCharToUpperCase) {
				cammelized.append(nameParts[i].charAt(0));
			} else {
				cammelized.append(Character.toUpperCase(nameParts[i].charAt(0)));	
			}
			cammelized.append(nameParts[i].substring(1));
		}
		return cammelized.toString();
	}

	private static final void log(Object... obj) {
		if (obj == null) {
			return;
		}
		if (obj.length == 1) {
			Object object = obj[0];
			if (object instanceof Collection) {
				((Collection<?>) object).forEach(System.out::println);
			} else {
				System.out.println(obj[0]);
			}
		} else {
			System.out.println(Arrays.toString(obj));
		}
	}

	// add to jvm exit hook ?
	private static void releaseResources() {
		db.close();
	}

	private static final void printLogo() {
		System.out.println(
			"\t _  _ _  __  _| _  _\n" +
			"\t(_)(-| )    (_|(_|(_)\n" +
			"\t_/ \n");
	}
}
